{
  #include "klox_tok.h"
}

%% # A1 Lox grammar
%% https://craftinginterpreters.com/appendix-i.html
%% 
%% ## A1.1 Syntax Grammar
%% 
%% The syntactic grammar is used to parse the linear sequence of tokens into
%% the nested syntax tree structure. It starts with the first rule that matches
%% an entire Lox program (or a single REPL entry).

program        = (__ declaration)* _EOF_ ;

%% ## A1 . 1 . 1 Declarations
%% 
%% A program is a series of declarations, which are the statements that bind new
%% identifiers or any of the other statement types.

declaration    = classDecl
               / funDecl
               / varDecl
               / statement ;

classDecl      = _'class' _SPC_ IDENTIFIER ( __ _'<' __ IDENTIFIER )?
                 __ _'{' (__ function)* __ _'}' ;
funDecl        = _'fun' _SPC_ function ;
varDecl        = _'var' _SPC_ IDENTIFIER ( __ _'=' expression )? __ _';' ;

%% # A1 . 1 . 2 Statements
%% 
%% The remaining statement rules produce side effects, but do not introduce bindings.

statement = __ ( exprStmt
               / forStmt
               / ifStmt
               / printStmt
               / returnStmt
               / whileStmt
               / block
               ) ;

exprStmt       = expression __ _';' ;
forStmt        = _'for' __ _'(' __ ( varDecl / exprStmt / _';' )
                           expression? __ _';'
                           expression? __ _')' statement ;
ifStmt         = _'if' __ _'(' expression __ _')' statement
                 ( _"'else' !& i" statement )? ;
printStmt      = _"'print' !& i" expression __ _';' ;
returnStmt     = _"'return' !& i" expression? __ _';' ;
whileStmt      = _'while' __ _'(' expression __ _')' statement ;
block          = _'{' (__ declaration)* __ _'}' ;

%% Note that block is a statement rule, but is also used as a nonterminal
%% in a couple of other rules for things like function bodies.

%% ## A1 . 1 . 3 Expressions
%% 
%% Expressions produce values. Lox has a number of unary and binary operators
%% with different levels of precedence. Some grammars for languages do not
%% directly encode the precedence relationships and specify that elsewhere.
%% Here, we use a separate rule for each precedence level to make it explicit.

expression     = __ assignment ;

assignment     = ( call _'.' )? IDENTIFIER __ _'=' __ assignment
               / logic_or ;

logic_or       = logic_and ( OP_OR logic_and )* ;
logic_and      = equality ( OP_AND equality )* ;
equality       = comparison ( OP_EQ comparison )* ;
comparison     = term ( OP_CMP term )* ;
term           = factor ( OP_ADD factor )* ;
factor         = unary ( OP_MULT unary )* ;

      % CHANGE % Need to allow for a potentially excluded `DOT` `IDENTIFIER`
               % squence at the end    ╭────────────────╮
               %                       ▼                ▼
unary     = __ ( OP_UNARY unary / call (_'.' IDENTIFIER)? ) ;


      % CHANGE % Added the look ahead pattern `"&[.(]"` to avoid `call` consuming
               % all the sequence of `DOT` `IDENTIFIER`              ╭──────╮
               %                                                     ▼      ▼
call           = primary ( __ _'(' arguments? _')' / _'.' IDENTIFIER _"&[.(]" )* ;

primary   = __ ( TRUE / FALSE / NIL / THIS
               / NUMBER / STRING / IDENTIFIER / _'(' expression __ _')'
               / SUPER _'.' IDENTIFIER
               ) ;

OP_OR    = __ _"'or' !& i" ;
OP_AND   = __ _"'and' !& i" ;
OP_EQ    = __ (_'!=' #?=TOK_NEQ / _'==' #?=TOK_EQ) ;
OP_CMP   = __ (_'>=' #?=TOK_GE  / _'>'  #?=TOK_GT  / _'<=' #?=TOK_LE / _'<' #?=TOK_LT) ;
OP_ADD   = __ ( _'-' #?=TOK_SUB / _'+'  #?=TOK_ADD ) ;
OP_MULT  = __ ( _'/' #?=TOK_DIV / _'*'  #?=TOK_MULT) ;
OP_UNARY = __ ( _'!' #?=TOK_NOT / _'-'  #?=TOK_NEG) ;

TRUE     = _'true';
FALSE    = _'false';
NIL      = _'nil';
THIS     = _'this';
SUPER    = _'super';

%% ## A1 . 1 . 4 Utility rules
%% 
%% In order to keep the above rules a little cleaner, some of the grammar is
%% split out into a few reused helper rules.

function       = IDENTIFIER _'(' __ parameters? __ _')' __ block ;
parameters     = IDENTIFIER ( __ _',' IDENTIFIER )* ;
arguments      = expression ( __ _',' expression )* ;

%% ## A1 . 2 Lexical Grammar
%% 
%% The lexical grammar is used by the scanner to group characters into tokens.
%% Where the syntax is context free, the lexical grammar is regular—note that
%% there are no recursive rules.

NUMBER         = _"+d ?'.' *d" / _"'.' +d" ;
STRING         = _"Q" ;
IDENTIFIER     = _"I" ;

_           =    (_"+s" / _"'//'N")* ;
SPC_        =    (_"+s" / _"'//'N")+ ;

EOF_        = __ _"!." ;
